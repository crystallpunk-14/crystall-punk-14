using System.Numerics;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Client.Utility;
using Robust.Shared.Input;

namespace Content.Client._CP14.UserInterface.Systems.NodeTree;

[GenerateTypedNameReferences]
public sealed partial class CP14NodeTreeGraphControl : BoxContainer
{
    [Dependency] private readonly IEntityManager _entManager = default!;

    private CP14NodeTreeUiState? _state;

    private CP14NodeTreeElement? _hoveredNode;
    private CP14NodeTreeElement? _selectedNode;

    private bool _dragging = false;
    private Vector2 _previousMousePosition = Vector2.Zero;
    private Vector2 _globalOffset = new (60,60);

    public event Action<CP14NodeTreeElement?>? OnNodeSelected;
    public event Action<Vector2>? OnOffsetChanged;

    public CP14NodeTreeGraphControl()
    {
        IoCManager.InjectDependencies(this);
        RobustXamlLoader.Load(this);

        OnOffsetChanged?.Invoke(_globalOffset);
    }

    public void UpdateState(CP14NodeTreeUiState state)
    {
        _state = state;
        OnOffsetChanged?.Invoke(_globalOffset);
    }

    protected override void KeyBindDown(GUIBoundKeyEventArgs args)
    {
        base.KeyBindDown(args);

        if (args.Handled)
            return;

        if (args.Function == EngineKeyFunctions.UIClick)
        {
            _dragging = true;

            if (_hoveredNode == null)
                return;

            OnNodeSelected?.Invoke(_hoveredNode);
            UserInterfaceManager.ClickSound();
            _selectedNode = _hoveredNode;
        }

        if (args.Function == EngineKeyFunctions.UIRightClick)
        {
            _globalOffset = new Vector2(60, 60); // Reset offset on right click
            OnOffsetChanged?.Invoke(_globalOffset);
        }
    }

    protected override void KeyBindUp(GUIBoundKeyEventArgs args)
    {
        base.KeyBindUp(args);

        if (args.Handled || args.Function != EngineKeyFunctions.UIClick)
            return;

        _dragging = false;
    }

    protected override void ExitedTree()
    {
        base.ExitedTree();

        OnNodeSelected?.Invoke(null);
    }

    protected override void Draw(DrawingHandleScreen handle)
    {
        base.Draw(handle);

        if (_state is null)
            return;

        _hoveredNode = null;

        var cursor = (UserInterfaceManager.MousePositionScaled.Position * UIScale) - GlobalPixelPosition;

        if (_dragging)
        {
            var delta = cursor - _previousMousePosition;
            _globalOffset += delta;
            OnOffsetChanged?.Invoke(_globalOffset);
        }

        _previousMousePosition = cursor;

        //Draw connection lines
        foreach (var node in _state.Nodes)
        {
            var fromPos = node.UiPosition * UIScale + _globalOffset;

            foreach (var child in node.Childrens)
            {
                foreach (var possibleChildNode in _state.Nodes)
                {
                    if (possibleChildNode.NodeKey != child)
                        continue;

                    // Draw line to child node
                    var childPos = possibleChildNode.UiPosition * UIScale + _globalOffset;
                    handle.DrawLine(fromPos, childPos, Color.White);
                    break;
                }
            }
        }

        //Draw skill icons over lines
        foreach (var node in _state.Nodes)
        {
            var pos = node.UiPosition * UIScale + _globalOffset;

            // Frame
            var frameTexture = _state.FrameIcon.Frame0();
            var frameSize = new Vector2(frameTexture.Width, frameTexture.Height) * 1.5f * UIScale;
            var frameQuad = new UIBox2(pos - frameSize / 2, pos + frameSize / 2);
            handle.DrawTextureRect(frameTexture, frameQuad, node.Active ? Color.White : Color.FromSrgb(new Color(0.6f, 0.6f, 0.6f)));

            // Base skill icon
            var baseTexture = node.Icon.Frame0();
            var baseSize = new Vector2(baseTexture.Width, baseTexture.Height) * 1.5f * UIScale;
            var baseQuad = new UIBox2(pos - baseSize / 2, pos + baseSize / 2);
            handle.DrawTextureRect(baseTexture, baseQuad, node.Active ? Color.White : Color.FromSrgb(new Color(0.6f, 0.6f, 0.6f)));

            // Selected Skill
            if (_selectedNode == node)
            {
                var selectedTexture = _state.SelectedIcon.Frame0();
                var selectedSize = new Vector2(selectedTexture.Width, selectedTexture.Height) * 1.5f * UIScale;
                var selectedQuad = new UIBox2(pos - selectedSize / 2, pos + selectedSize / 2);
                handle.DrawTextureRect(selectedTexture, selectedQuad, Color.White);
            }

            // Hovered Skill
            var hovered = (cursor - pos).LengthSquared() <= (baseSize.X / 2) * (baseSize.X / 2);
            if (hovered)
            {
                _hoveredNode = node;
                var hoveredTexture = _state.SelectedIcon.Frame0();
                var hoveredSize = new Vector2(hoveredTexture.Width, hoveredTexture.Height) * 1.5f * UIScale;
                var hoveredQuad = new UIBox2(pos - hoveredSize / 2, pos + hoveredSize / 2);
                handle.DrawTextureRect(hoveredTexture, hoveredQuad, Color.White);
            }

            // Learned Skill
            if (node.Active)
            {
                var learnedTexture = _state.LearnedIcon.Frame0();
                var learnedSize = new Vector2(learnedTexture.Width, learnedTexture.Height) * 1.5f * UIScale;
                var learnedQuad = new UIBox2(pos - learnedSize / 2, pos + learnedSize / 2);
                handle.DrawTextureRect(learnedTexture, learnedQuad, Color.White);
            }
        }
    }
}
